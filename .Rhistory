i=1:N,
name=unlist(aux[[var]]["name"]),
value=sample(aux[[var]][["options"]],size=N, prob=aux[[var]][["distribution"]],replace=TRUE)
)
}
vars <- do.call("bind_rows",vars)
vars <- vars %>% pivot_wider(names_from=name,values_from=value)
df<- tibble(
i=1:N,
DOB= birth_times,
DOR= removal_times)
exp<- tidyr::expand_grid(1:N, times)
exp<-dplyr::rename(exp,i="1:N")
dem<- exp %>% dplyr::left_join(df, by="i")
dem1<- dem %>% left_join(vars, by="i")
return(dem1)
}
}
demography<- generate_pop_demography(N, times, birth_times, removal_times, aux=aux)
#' @param N The number of individuals in the simulation
#' @param times The total number of time steps in the simulation
#' @param birth_times
#' @param removal_times
#' @param aux
#'
#' @return
#' @export
#'
#' @examples
generate_pop_demography<-function(N, times, birth_times, removal_times, aux=NULL){
if(is.null(aux)){
df<- tibble(
i=1:N,
birth_times= birth_times,
removal_times= removal_times)
exp<- tidyr::expand_grid(1:N, times)
exp<-dplyr::rename(exp,i="1:N")
dem<- exp %>% dplyr::left_join(df, by="i")
return(dem)
}
if(!is.null(aux)){
vars <- NULL
for(var in seq_along(aux)){
vars[[var]] <- tibble(
i=1:N,
name=unlist(aux[[var]]["name"]),
value=sample(aux[[var]][["options"]],size=N, prob=aux[[var]][["distribution"]],replace=TRUE)
)
}
vars <- do.call("bind_rows",vars)
vars <- vars %>% pivot_wider(names_from=name,values_from=value)
df<- tibble(
i=1:N,
birth_times= birth_times,
removal_times= removal_times)
exp<- tidyr::expand_grid(1:N, times)
exp<-dplyr::rename(exp,i="1:N")
dem<- exp %>% dplyr::left_join(df, by="i")
dem1<- dem %>% left_join(vars, by="i")
return(dem1)
}
}
demography<- generate_pop_demography(N, times, birth_times, removal_times, aux=aux)
#' @param times The total number of time steps in the simulation
#' @param birth_times A vector of all individual's birth times
#' @param removal_min The minimum age at which an individual can be removed from the population
#' @param removal_max The maximum age at which an individual can be removed from the population
#' @param prob_removal The probability that an individual will be removed from the population
#'
#' @return A vector of all individual's removal times is returned
#' @export
#'
#' @examples
simulate_removal_times <- function(N, times, birth_times, removal_min, removal_max, prob_removal){
removal_histories <- matrix(0, nrow=N, ncol=length(times))
for(i in 1:N){
tmp <- removal_histories[i,]
#Cannot be removed before birth and removal_min
tmp[times < birth_times[i] + removal_min] <- NA
#Find removal time
if(birth_times[i]>removal_min){
removal_time <- sample(times[times > birth_times[i] + (removal_min) & times < birth_times[i] + (removal_max)], 1)
tmp[removal_time] <- ifelse(runif(1) < prob_removal, 1, 0) #this step can be removed?
}
removal_histories[i,] <- tmp
}
removal_histories_reshaped <- reshape2::melt(removal_histories) %>% dplyr::mutate(value=as.factor(value))
colnames(removal_histories_reshaped) <- c("Individual","Time","Removed?")
removed<-removal_histories_reshaped %>% dplyr::filter(removal_histories_reshaped$`Removed?`==1) %>%  dplyr::mutate(removal_times=Time) %>% dplyr::select(Individual, removal_times)
df<- tibble(Individual= 1:N)
df1<- df %>% dplyr::left_join(removed, by="Individual")
return(df1$removal_times)
}
#' @param N The number of individuals in the simulation
#' @param times The total number of time steps in the simulation
#' @param birth_times A vector of all individual's birth times
#' @param removal_times A vector of all individual's removal times
#' @param aux A list of the demography columns, the variable options and their distributions; defaults to NULL
#'
#' @return
#' @export
#'
#' @examples
generate_pop_demography<-function(N, times, birth_times, removal_times, aux=NULL){
if(is.null(aux)){
df<- tibble(
i=1:N,
birth_times= birth_times,
removal_times= removal_times)
exp<- tidyr::expand_grid(1:N, times)
exp<-dplyr::rename(exp,i="1:N")
dem<- exp %>% dplyr::left_join(df, by="i")
return(dem)
}
if(!is.null(aux)){
vars <- NULL
for(var in seq_along(aux)){
vars[[var]] <- tibble(
i=1:N,
name=unlist(aux[[var]]["name"]),
value=sample(aux[[var]][["options"]],size=N, prob=aux[[var]][["distribution"]],replace=TRUE)
)
}
vars <- do.call("bind_rows",vars)
vars <- vars %>% pivot_wider(names_from=name,values_from=value)
df<- tibble(
i=1:N,
birth_times= birth_times,
removal_times= removal_times)
exp<- tidyr::expand_grid(1:N, times)
exp<-dplyr::rename(exp,i="1:N")
dem<- exp %>% dplyr::left_join(df, by="i")
dem1<- dem %>% left_join(vars, by="i")
return(dem1)
}
}
removal_times<-simulate_removal_times(N, times, birth_times, removal_min=0, removal_max=100, prob_removal=0.9)
aux <- list("SES"=list("name"="SES","options"=c("low","medium","high"), "distribution"=c(0.2,0.2,0.6)),
"NS"=list("name"="NS","options"=c("low","high"),"distribution"=c(0.5,0.5)),
"Sex"=list("name"="Sex","options"=c("male", "female"), "distribution"=c(0.5,0.5)),
"Location"=list("name"="Location","options"=c("North", "South", "East", "West"), "distribution"=c(0.25,0.25,0.25,0.25)) )
demography<- generate_pop_demography(N, times, birth_times, removal_times, aux=aux)
# ?simulate_birth_times
N_alive <- find_N_alive(N, times)
# ?find_N_alive
plot_age_distribution(birth_times)
plot_age_distribution(removal_times)
?find_N_alive
#### POPULATION PARAMETERS####
N <- 10 # number of individuals in the study population
years <- 1 # number of years to run the simulation for
t_periods_per_year <- 12 # number of time periods per year (12 months)
times<- seq(1,years*t_periods_per_year, by=1) # creates a vector of all months in 10 years
N_pathogens<-2
obs_time <-120 # time step when the serosurvey is conducted
vacc_min <- 9 # time step when an individual becomes eligible for vaccination
vacc_max <- 60 #time step at which an individual becomes too old to get vaccinated
birth_times <-simulate_birth_times(N, times, limit=vacc_min)
# ?simulate_birth_times
# N_alive <- find_N_alive(N, times)  #This function doesn't work when individual's are removed from the population
# ?find_N_alive
plot_age_distribution(birth_times)
removal_min <- 0 # the minimum age at which an individual can be removed from the population
removal_max <- 100 # the maximum age at which an individual can be removed from the population
prob_removal <- 0.9 # the probability that an individual will be removed from the population
removal_times<-simulate_removal_times(N, times, birth_times, removal_min=0, removal_max=100, prob_removal=0.9)
removal_times
# ?simulate_removal_times
plot_age_distribution(removal_times)
#pre load the demography categories, values and distributions
aux <- list("SES"=list("name"="SES","options"=c("low","medium","high"), "distribution"=c(0.2,0.2,0.6)),
"NS"=list("name"="NS","options"=c("low","high"),"distribution"=c(0.5,0.5)),
"Sex"=list("name"="Sex","options"=c("male", "female"), "distribution"=c(0.5,0.5)),
"Location"=list("name"="Location","options"=c("North", "South", "East", "West"), "distribution"=c(0.25,0.25,0.25,0.25)) )
demography<- generate_pop_demography(N, times, birth_times, removal_times, aux=aux)
source("~/Documents/GitHub/serosim/R/run_simulation_JAH.R", echo=TRUE)
source("~/Documents/GitHub/serosim/scripts/main_test_JAH.R", echo=TRUE)
source("~/Documents/GitHub/serosim/R/run_simulation_JAH.R", echo=TRUE)
source("~/Documents/GitHub/serosim/scripts/main_test_JAH.R", echo=TRUE)
#' @param N The number of individuals in the simulation
#' @param times The total number of time steps in the simulation
#' @param birth_times A vector of all individual's birth times
#' @param removal_times A vector of all individual's removal times
#' @param aux A list of the demography columns, the variable options and their distributions; defaults to NULL
#'
#' @return
#' @export
#'
#' @examples
generate_pop_demography<-function(N, times, birth_times, removal_times, aux=NULL){
if(is.null(aux)){
df<- tibble(
i=1:N,
birth= birth_times,
removal= removal_times)
exp<- tidyr::expand_grid(1:N, times)
exp<-dplyr::rename(exp,i="1:N")
dem<- exp %>% dplyr::left_join(df, by="i")
return(dem)
}
if(!is.null(aux)){
vars <- NULL
for(var in seq_along(aux)){
vars[[var]] <- tibble(
i=1:N,
name=unlist(aux[[var]]["name"]),
value=sample(aux[[var]][["options"]],size=N, prob=aux[[var]][["distribution"]],replace=TRUE)
)
}
vars <- do.call("bind_rows",vars)
vars <- vars %>% pivot_wider(names_from=name,values_from=value)
df<- tibble(
i=1:N,
birth= birth_times,
removal= removal_times)
exp<- tidyr::expand_grid(1:N, times)
exp<-dplyr::rename(exp,i="1:N")
dem<- exp %>% dplyr::left_join(df, by="i")
dem1<- dem %>% left_join(vars, by="i")
return(dem1)
}
}
#### ANTIBODY KINETICS PARAMATERS####
#Define antibody kinetics parameters
#Antibody kinetics parameters should be on the normal scale
# ?load_kinetics_parameters
kinetics_pars<-load_kinetics_parameters(boost_infection_long_mean_1=9000, boost_infection_long_var_1=500,
wane_infection_long_mean_1=0, wane_infection_long_var_1=0,
boost_infection_short_mean_1=3000, boost_infection_short_var_1=500,
wane_infection_short_mean_1=1/120, wane_infection_short_var_1=0,
boost_vacc_long_mean_1=3000, boost_vacc_long_var_1=500,
wane_vacc_long_mean_1=0, wane_vacc_long_var_1=0,
boost_vacc_short_mean_1=1000,boost_vacc_short_var_1=1000,
wane_vacc_short_mean_1=1/120, wane_vacc_short_var_1=0,
titre_ceiling_gradient_1=0.5/200, titre_ceiling_threshold_1=200,
boost_infection_long_mean_2=9000,boost_infection_long_var_2=500,
wane_infection_long_mean_2=0, wane_infection_long_var_2=0,
boost_infection_short_mean_2=3000, boost_infection_short_var_2=500,
wane_infection_short_mean_2=1/120, wane_infection_short_var_2=0,
boost_vacc_long_mean_2=3000, boost_vacc_long_var_2=500,
wane_vacc_long_mean_2=0,wane_vacc_long_var_2=0,
boost_vacc_short_mean_2=1000, boost_vacc_short_var_2=500,
wane_vacc_short_mean_2=1/120, wane_vacc_short_var_2=0,
titre_ceiling_gradient_2=0.5/200, titre_ceiling_threshold_2=200)
kinetics_pars
draw_parameters <- function(i, t, e, ag, demography, theta, antibody_state, ...){
## Filter for only exposure and ag's stimulated
theta_tmp <- theta %>% filter(exposure_id == e)
pars <- numeric(nrow(theta_tmp))
par_names <- character(nrow(theta_tmp))
## For each parameter; randomly sample for the distribution given the mean and sd
for(par in 1:nrow(theta_tmp)){
if(theta_tmp$distribution == "normal"){
pars[par] <- rnorm(1, theta_tmp$mean[par], theta_tmp$sd[par])
par_names[par] <- theta_tmp$name[par]
}
if(theta_tmp$distribution == "log-normal"){
pars[par] <- rlnorm(1, theta_tmp$mean[par], theta_tmp$sd[par])
par_names[par] <- theta_tmp$name[par]
}
}
all_pars <- tibble(i=i, t=t, e=e, ag=ag, name=par_names, value=pars)
return(all_pars)
}
draw_parameters <- function(i, t, e, ag, demography, theta, antibody_state, ...){
## Filter for only exposure stimulated
theta_tmp <- theta %>% filter(exposure_id == e)
pars <- numeric(nrow(theta_tmp))
par_names <- character(nrow(theta_tmp))
## For each parameter; randomly sample from the distribution given the mean and sd
for(par in 1:nrow(theta_tmp)){
if(theta_tmp$distribution == "normal"){
pars[par] <- rnorm(1, theta_tmp$mean[par], theta_tmp$sd[par])
par_names[par] <- theta_tmp$name[par]
}
if(theta_tmp$distribution == "log-normal"){
pars[par] <- rlnorm(1, theta_tmp$mean[par], theta_tmp$sd[par])
par_names[par] <- theta_tmp$name[par]
}
}
all_pars <- tibble(i=i, t=t, e=e, ag=ag, name=par_names, value=pars)
return(all_pars)
}
#' @param ag Antigen
#' @param demography Population demography dat set
#' @param theta Antibody kinetics parameters
#' @param antibody_state
#' @param ...
#'
#' @return
#' @export
#'
#' @examples
draw_parameters <- function(i, t, e, ag, demography, theta, antibody_state, ...){
## Filter for only exposure stimulated
theta_tmp <- theta %>% filter(exposure_id == e)
pars <- numeric(nrow(theta_tmp))
par_names <- character(nrow(theta_tmp))
## For each parameter; randomly sample from the distribution given the mean and sd
for(par in 1:nrow(theta_tmp)){
if(theta_tmp$distribution == "log-normal"){
pars[par] <- rlnorm(1, theta_tmp$mean[par], theta_tmp$sd[par])
par_names[par] <- theta_tmp$name[par]
}
else{
pars[par] <- rnorm(1, theta_tmp$mean[par], theta_tmp$sd[par])
par_names[par] <- theta_tmp$name[par]
}
#Add titre-dependent boosting
if(par_names[par] %in% c("boost_short","boost_long")){
titre_threshold <- min(antibody_states[i,t1,ag], theta_tmp[theta_tmp$name=="titre_ceiling_threshold" & theta_tmp$ag==ag, "mean"])
pars[par] <- pars[par]*(1-theta_tmp[theta_tmp$name=="titre_ceiling_gradient" & theta_tmp$ag==ag, "mean"]*titre_threshold)
}
}
all_pars <- tibble(i=i, t=t, e=e, ag=ag, name=par_names, value=pars)
return(all_pars)
}
N <- 10
times <- seq(1,100,by=1)
demography <- tibble(i=1:N,birth=rep(1,N), death=rep(NA,N),location=rep(1,N))
simulation_settings <- list("t_start"=1,"t_end"=max(times))
observation_times <- NULL
lambdas <- array(rep(0.01,length(times)), dim=c(length(times),1,1))
antigen_map <- tibble(exposure_id=1,antigen_id=1)
theta <- list("boost_mean"=2,"boost_sd"=1)
exposure_model <- function(i, t, e, l, lambdas, demography){
p <- lambdas[t, e, l]
p
}
immunity_model <- function(i, t, e, exposure_histories,
antibody_states, demography, antigen_map,...){
return(1)
}
observation_model <- NULL
draw_parameters <- function(i, t, e, ag, demography, theta, antibody_state, ...){
boost <- rnorm(1, theta[["boost_mean"]],theta[["boost_sd"]])
tibble(i=i, t=t, e=e, ag=ag, name="boost",value=boost)
}
antibody_model <- function(i,t1,ag, exposure_histories,kinetics_parameters,antigen_map){
exp_history <- exposure_histories[i,1:(t1-1),]
y <- 0
if(t1 > 1 & sum(exp_history > 0)){
tmp_boosts <- kinetics_parameters[[i]] %>% filter(t < t1) %>%
filter(name == "boost") %>% pull(value)
for(ts in seq_along(tmp_boosts)){
y <- y + tmp_boosts[ts]
}
}
y
}
res <- serosim(simulation_settings, demography, observation_times,
lambdas, antigen_map, theta,
exposure_model, immunity_model, antibody_model, observation_model, draw_parameters)
image(t(res$antibody_states[,,1]))
serosim <- function(
simulation_settings, ## List of parameters governing the simulation settings
demography=NULL, ## tibble of demographic information for each individual
observation_times=NULL, ## tibble of observation times and antigen for each individual
lambdas, ## 3D matrix giving force of infection for each exposure ID, location and time
antigen_map, ## Object determining relationship between exposure IDs and antigens
theta,
exposure_model, ## Calculates the probability of infection given the FOI matrix, lambda
immunity_model, ## function determining probability of infection conditional on lambdas and individuals immune state
antibody_model, ## function determining antibody state as a function of exposure history and kinetics parameters (theta)
observation_model, ## function generating observed titers as a function of latent titers and theta
draw_parameters, ## function to simulate antibody kinetics parameters
...
){
## Extract key demographic information
indivs <- unique(demography$i)
N <- length(indivs)
## Note "birth" refers to first time point in the population and "death" refers to time point of removal from population
birth_times <- demography %>% select(i, birth) %>% distinct()
death_times <- demography %>% select(i, death) %>% distinct()
## If no location information provided, assume 1 location
## ...
locations <- demography %>% select(i, location) %>% distinct()
## Extract information on number of exposure types
exposure_ids <- unique(antigen_map$exposure_id)
antigen_ids <- unique(antigen_map$antigen_id)
N_exposure_ids <- length(exposure_ids)
N_antigen_ids <- length(antigen_ids)
simulation_times <- seq(simulation_settings[["t_start"]],simulation_settings[["t_end"]],1)
## Create empty matrix to store exposure histories
exposure_histories <- array(NA, dim=c(N, length(times), N_exposure_ids))#create_matrix(N_exposure_ids, N, simulation_times, fill=NA)
antibody_states <- array(0, dim=c(N, length(times), N_antigen_ids))##create_matrix(N_antigen_ids, N, simulation_times, fill=0)
kinetics_parameters <- vector(mode="list",length=N)
## Merge in any pre-specified exposure history information
## ...
message(cat("Beginning simulation\n"))
## For each individual
for(i in indivs){
message(cat("Individual: ", i, "\n"))
## Pull birth time for this individual
birth_time <- birth_times$birth[i]
death_time <- ifelse(is.na(death_times$death[i]), simulation_settings[["t_end"]], death_times$death[i])
l <- locations$location[i]
## Only consider times that the individual was alive for
simulation_times_tmp <- simulation_times[simulation_times >= birth_time &
simulation_times <= death_time]
## Go through all times relevant to this individual
for(t in simulation_times_tmp){
## Work out antibody state for each antigen
## The reason we nest this at the same level as the exposure history generation is
## that exposure histories may be conditional on antibody state
for(ag in antigen_ids){
antibody_states[i,t,ag] <- antibody_model(i, t, ag, exposure_histories,
kinetics_parameters, antigen_map)
}
## Work out exposure result for each exposure ID
for(e in exposure_ids){
## Only update if exposure history entry is NA here. If not NA, then pre-specified
if(is.na(exposure_histories[i,t,e])){
## What is the probability that exposure occurred?
prob_exposed <- exposure_model(i, t, e, l, lambdas, demography, ...)
## If an exposure event occurred, what's the probability
## of successful infection/vaccination?
successful_exposure <- 0
if(runif(1)<prob_exposed){
prob_success <- immunity_model(i, t, e, exposure_histories,
antibody_states, demography,
antigen_map, ...)
## Randomly assign success of exposure event based on immune state
successful_exposure <- as.integer(runif(1) < prob_success)
## Create kinetics parameters for this exposure event
## Each successful exposure event will create a tibble with parameters
## for this event, drawn from information given in theta
## We also pass the demographic information in case we want demography-specific parameters
kinetics_parameters[[i]] <- bind_rows(kinetics_parameters[[i]],
draw_parameters(i, t, e, demography, theta, ...))
}
exposure_histories[i,t,e] <- successful_exposure
}
}
}
}
all_kinetics_parameters <- do.call("bind_rows", kinetics_parameters)
## Observation process
observed_antibody_states <- NULL
return(list("exposure_histories"=exposure_histories,
"antibody_states"=antibody_states,
"observed_antibody_states"=observed_antibody_states,
"kinetics_parameters"=all_kinetics_parameters))
}
res <- serosim(simulation_settings, demography, observation_times,
lambdas, antigen_map, theta,
exposure_model, immunity_model, antibody_model, observation_model, draw_parameters)
source("~/Documents/GitHub/serosim/R/run_simulation_JAH.R", echo=TRUE)
source("~/Documents/GitHub/serosim/scripts/main_test_JAH.R", echo=TRUE)
source("~/Documents/GitHub/serosim/R/run_simulation_JAH.R", echo=TRUE)
N <- 10
times <- seq(1,100,by=1)
demography <- tibble(i=1:N,birth=rep(1,N), death=rep(NA,N),location=rep(1,N))
simulation_settings <- list("t_start"=1,"t_end"=max(times))
t_start
simulation_settings <- list("t_start"=1,"t_end"=max(times))
simulation_settings
observation_times <- NULL
lambdas <- array(rep(0.01,length(times)), dim=c(length(times),1,1))
lambdas
times <- seq(1,100,by=1)
demography <- tibble(i=1:N,birth=rep(1,N), death=rep(NA,N),location=rep(1,N))
simulation_settings <- list("t_start"=1,"t_end"=max(times))
observation_times <- NULL
lambdas <- array(rep(0.01,length(times)), dim=c(length(times),1,1))
antigen_map <- tibble(exposure_id=1,antigen_id=1)
theta <- list("boost_mean"=2,"boost_sd"=1)
exposure_model <- function(i, t, e, l, lambdas, demography){
p <- lambdas[t, e, l]
p
}
immunity_model <- function(i, t, e, exposure_histories,
antibody_states, demography, antigen_map,...){
return(1)
}
observation_model <- NULL
draw_parameters <- function(i, t, e, ag, demography, theta, antibody_state, ...){
boost <- rnorm(1, theta[["boost_mean"]],theta[["boost_sd"]])
tibble(i=i, t=t, e=e, ag=ag, name="boost",value=boost)
}
antibody_model <- function(i,t1,ag, exposure_histories,kinetics_parameters,antigen_map){
exp_history <- exposure_histories[i,1:(t1-1),]
y <- 0
if(t1 > 1 & sum(exp_history > 0)){
tmp_boosts <- kinetics_parameters[[i]] %>% filter(t < t1) %>%
filter(name == "boost") %>% pull(value)
for(ts in seq_along(tmp_boosts)){
y <- y + tmp_boosts[ts]
}
}
y
}
res <- serosim(simulation_settings, demography, observation_times,
lambdas, antigen_map, theta,
exposure_model, immunity_model, antibody_model, observation_model, draw_parameters)
theta
source("~/Documents/GitHub/serosim/scripts/main_test_JAH.R", echo=TRUE)
source("~/Documents/GitHub/serosim/R/run_simulation_JAH.R", echo=TRUE)
simulation_times <- seq(simulation_settings[["t_start"]],simulation_settings[["t_end"]],1)
simulation_times
indivs <- unique(demography$i)
indivs
N <- length(indivs)
N
## Note "birth" refers to first time point in the population and "death" refers to time point of removal from population
birth_times <- demography %>% select(i, birth) %>% distinct()
birth_times
death_times <- demography %>% select(i, death) %>% distinct()
death_times
source("~/Documents/GitHub/serosim/scripts/main_test_JAH.R", echo=TRUE)
Rprof(NULL)
summaryRprof(tmp)
